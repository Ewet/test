<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
		<p>类，类的继承</p>
		<button style="font-size: 50px;" type="button">kkdkdk</button>
		<script type="text/javascript">
			// 通过构造函数(constructor)创建一个类
			function Dog(name) {
				this.name = name;
			}
			// 通过一个new 关键字实例化一个类成为对象;
			var v1 = new Dog("ak");
			console.log(v1.name)
			console.log(v1.constructor)
			// prototype 原型
			// 定义私有属性,防止每次实例化时都需要加载一遍里面的方法;
			Dog.prototype = {
				bark:function(){
					console.log(this.name + "bark")
				}
			}
			var d1 = new Dog("dodo");
			d1.bark()
			
			// 定义已经实例化了的实例的方法;
			Dog.prototype.run = function(){
				console.log("isRunning!")
			}
			d1.run()
			
			// 实现类的继承
			function Cat(name) {
				this.name = name;
			}
			Cat.prototype = {
				bark: function(){
					console.log("person bark fun")
				}
			}
			// 重置Cat实例的构造函数为本身;
			Cat.prototype.constructor = Cat;
			
			function Pig(name) {
				// 继承Cat的构造函数
				Cat.call(this, name),
				// 自己的属性
				this.color = "red";
			}
			// 继承Cat的是有属性;
			Pig.prototype = new Cat();
			// 另一种继承方法
			Pig.prototype = Object.create(Cat.prototype)
			
			Pig.prototype.constructor = Pig;
			// 使用定义的类,通过实例化成对象的方式
			var ha = new Pig("pig")
			console.log(ha.name)
			console.log(ha.color)
			ha.bark()
			// 查看一个对象的原型链
			console.log(ha.__proto__)
			
			// es6的实现方法
			// 声明一个类
			class Pandar {
				// 构造函数
				constructor(name) {
					this.name = name;
				}
				// 普通方法
				dark(){
					console.log("dark")
				}
				// 类的方法
				static staticMethod() {
					console.log("static method")
				}
			}
			// 通过关键字~extend~来实现继承
			class sheep extends Pandar {
				constructor(name){
					// 调用父类的构造函数
					super(name)
					this.type = "type"
				}
				// 定义自己的方法
				say(){
					console.log("say fun");
				}
			}
		</script>
	</body>
</html>
